<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>EXO HUNT APP</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <style>
        /* Quick inline fixes to make selects readable */
        label { display: block; margin: 5px 0; }
        select { margin-left: 10px; }
        .hidden { display: none; }
        .button-container { margin-top: 15px; }
        
        /* Updated style for metrics */
        .metrics-section {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            /* ðŸš¨ Changed background-color to black and text color to white */
            background-color: black; 
            color: white; /* Ensure text is readable on a black background */
        }
        .metrics-section h3 {
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        .metrics-section pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            /* Ensure the preformatted text is also white */
            color: white; 
        }
        /* Style for the tooltip span */
        .feature-label {
            border-bottom: 1px dotted #aaa; /* Add a hint that it's clickable/hoverable */
            cursor: help;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>ðŸŒŒ EXO HUNT APP ðŸŒŒ</h1>
    <p class="subtitle">NASA SPACE APPS 2025 - Worlds Away Challenge</p>
    <p>Upload your CSV and map columns to run predictions!</p>

    <input type="file" id="csvFile" accept=".csv">

    <div id="modelSelection">
        <label for="stackSelect">Choose a model stack:</label>
        <select id="stackSelect">
            <option value="" selected disabled>Select Stack</option>
            <option value="stack1">XGB*RFR + MLP Stack</option>
            <option value="stack2">XGB*CATB + MLP Stack</option>
        </select>
    </div>

    <div id="columnMapping" class="hidden">
        <h3>Map CSV columns to model features:</h3>
    </div>

    <div class="button-container">
        <button type="button" id="submitBtn">Run Model</button>
    </div>

    <div id="results" class="hidden">
        <h2>Predictions</h2>
        <p><strong>0 = CANDIDATE | 1 = CONFIRMED PLANET | 2 = FALSE POSITIVE</strong></p>
        
        <div id="modelMetrics" class="metrics-section">
            <h3>Model Performance Metrics</h3>
            <pre id="metricsOutput"></pre>
        </div>

        <h3 style="margin-top: 20px;">Backend Response (if error)</h3>
        <pre id="predOutput"></pre>
    </div>
</div>

<script>
// Define all model metrics here
const MODEL_METRICS = {
    "base": {
        "XGB": `Test Accuracy: 0.7420789327404114

Classification Report (Test):
                precision    recall  f1-score   support

     CANDIDATE       0.52      0.40      0.45       371
     CONFIRMED       0.76      0.85      0.80       546
FALSE POSITIVE       0.80      0.82      0.81       882

      accuracy                           0.74      1799
     macro avg       0.69      0.69      0.69      1799
  weighted avg       0.73      0.74      0.73      1799`,
        "RFR": `Test Accuracy: 0.7415230683713174

Classification Report (Test):
                precision    recall  f1-score   support

     CANDIDATE       0.51      0.39      0.44       371
     CONFIRMED       0.76      0.84      0.80       546
FALSE POSITIVE       0.80      0.83      0.81       882

      accuracy                           0.74      1799
     macro avg       0.69      0.69      0.68      1799
  weighted avg       0.73      0.74      0.73      1799`,
        "CATB": `Test Accuracy: 0.7448582545858811

Classification Report (Test):
                precision    recall  f1-score   support

     CANDIDATE       0.53      0.40      0.45       371
     CONFIRMED       0.77      0.85      0.81       546
FALSE POSITIVE       0.80      0.82      0.81       882

      accuracy                           0.74      1799
     macro avg       0.70      0.69      0.69      1799
  weighted avg       0.73      0.74      0.74      1799`
    },
    "stack1": `Test Accuracy: 0.7513768686073957
Classification Report per Class:
Class 0: Precision=0.5467, Recall=0.4500, F1=0.4937
Class 1: Precision=0.7673, Recall=0.8386, F1=0.8014
Class 2: Precision=0.8115, Recall=0.8223, F1=0.8168

Base Models Used: XGBoost, Random Forest.`,
    "stack2": `Test Accuracy: 0.7513768686073957
Classification Report per Class:
Class 0: Precision=0.5467, Recall=0.4500, F1=0.4937
Class 1: Precision=0.7673, Recall=0.8386, F1=0.8014
Class 2: Precision=0.8115, Recall=0.8223, F1=0.8168

Base Models Used: XGBoost, CatBoost.`
};


document.addEventListener("DOMContentLoaded", () => {
    const fileInput = document.getElementById("csvFile");
    const columnMappingDiv = document.getElementById("columnMapping");
    const stackSelect = document.getElementById("stackSelect");
    const submitBtn = document.getElementById("submitBtn");
    const predOutput = document.getElementById("predOutput");
    const resultsDiv = document.getElementById("results");
    // New element to hold metrics
    const metricsOutput = document.getElementById("metricsOutput"); 

    let csvData = [];
    let headers = [];

    // --- 1. SEPARATE BASE FEATURE ARRAYS ---
    // List of the REQUIRED feature names (technical names)
    const baseFeatures = [
        'insol', 'insol_err1', 'insol_err2',
        'period', 'period_err1', 'period_err2',
        'prad', 'prad_err1', 'prad_err2',
        'steff', 'steff_err1', 'steff_err2',
        'srad', 'srad_err1', 'srad_err2'
    ];
    
    // List of human-readable display names, matching the order of baseFeatures
    const baseFeatureDescriptions = [
        'Insolation Flux (Earth Flux)', 'Insolation Error 1', 'Insolation Error 2',
        'Orbital Period (days)', 'Period Error 1', 'Period Error 2',
        'Planetary Radius (Earth Radii)', 'Radius Error 1', 'Radius Error 2',
        'Stellar Temperature (K)', 'Stellar Temp Error 1', 'Stellar Temp Error 2',
        'Stellar Radius (Solar Radii)', 'Stellar Radius Error 1', 'Stellar Radius Error 2'
    ];

    // List of detailed definitions/tooltips, matching the order of baseFeatures
    const baseFeatureTooltips = [
        'Stellar insolation received by the planet, scaled to Earth.', 'Upper 1-sigma uncertainty on Insolation.', 'Lower 1-sigma uncertainty on Insolation.',
        'The time required to complete one orbit (in days).', 'Upper 1-sigma uncertainty on Orbital Period.', 'Lower 1-sigma uncertainty on Orbital Period.',
        'Radius of the planet relative to Earth.', 'Upper 1-sigma uncertainty on Planetary Radius.', 'Lower 1-sigma uncertainty on Planetary Radius.',
        'Effective temperature of the host star (in Kelvin).', 'Upper 1-sigma uncertainty on Stellar Temperature.', 'Lower 1-sigma uncertainty on Stellar Temperature.',
        'Radius of the host star relative to the Sun.', 'Upper 1-sigma uncertainty on Stellar Radius.', 'Lower 1-sigma uncertainty on Stellar Radius.'
    ];

    // Check that all arrays match in length
    if (baseFeatures.length !== baseFeatureDescriptions.length || baseFeatures.length !== baseFeatureTooltips.length) {
        console.error("Feature arrays are mismatched in length! Check your definitions.");
    }
    // ------------------------------------

    // Function to display metrics based on stack selection (unchanged)
    const displayMetrics = (stack) => {
        let output = "";
        
        // Always display the base model metrics
        output += "--- BASE MODEL METRICS ---\n\n";
        output += `[XGBoost]\n${MODEL_METRICS.base.XGB}\n\n`;
        
        if (stack === "stack1") {
            output += `[Random Forest (RFR)]\n${MODEL_METRICS.base.RFR}\n\n`;
            output += "--- STACK 1 (XGB*RFR + MLP) METRICS ---\n\n";
            output += MODEL_METRICS.stack1;
        } else if (stack === "stack2") {
            output += `[CatBoost (CATB)]\n${MODEL_METRICS.base.CATB}\n\n`;
            output += "--- STACK 2 (XGB*CATB + MLP) METRICS ---\n\n";
            output += MODEL_METRICS.stack2;
        }

        metricsOutput.textContent = output;
    };
    
    // Add event listener to stack select to show metrics (unchanged)
    stackSelect.addEventListener("change", (e) => {
        if (e.target.value) {
            displayMetrics(e.target.value);
            // Show the results div if a stack is selected, to display metrics
            resultsDiv.classList.remove("hidden"); 
        } else {
            metricsOutput.textContent = "";
            resultsDiv.classList.add("hidden"); 
        }
    });


    // --- Read CSV and populate selects (UPDATED) ---
    fileInput.addEventListener("change", (e) => {
        console.log("[DEBUG] File input triggered.");
        const file = e.target.files[0];
        
        if (!file) {
             columnMappingDiv.classList.add("hidden");
             return;
        }
        
        const reader = new FileReader();
        reader.onload = (event) => {
            console.log("[DEBUG] FileReader finished loading.");
            const text = event.target.result.trim();

            const rows = text.split("\n").filter(r => r.trim().length > 0);
            headers = rows[0].split(",");

            csvData = rows.slice(1).map(r => r.split(","));

            // Clear previous mapping
            columnMappingDiv.innerHTML = "<h3>Map CSV columns to model features:</h3>";

            // --- 2. Iterate using index to access all three arrays simultaneously ---
            baseFeatures.forEach((feature, index) => {
                const displayName = baseFeatureDescriptions[index];
                const description = baseFeatureTooltips[index];

                const label = document.createElement("label");
                
                // Use innerHTML to inject the span for the tooltip/cursor effect
                label.innerHTML = `<span class="feature-label" title="${description}">${displayName} (${feature})</span>: `;

                const select = document.createElement("select");
                select.dataset.feature = feature;

                // Add a disabled default option
                const defaultOption = document.createElement("option");
                defaultOption.value = "";
                defaultOption.textContent = `-- Select CSV column for ${displayName} --`;
                defaultOption.disabled = true;
                defaultOption.selected = true;
                select.appendChild(defaultOption);

                headers.forEach(h => {
                    const option = document.createElement("option");
                    option.value = h;
                    option.textContent = h;
                    select.appendChild(option);
                });

                label.appendChild(select);
                columnMappingDiv.appendChild(label);
            });
            // -------------------------------------------------------------------

            console.log("[DEBUG] Mapping dropdowns created.");
            columnMappingDiv.classList.remove("hidden");
        };

        reader.onerror = (err) => {
            console.error("[DEBUG] Error reading CSV:", err);
            alert("Failed to read CSV file.");
        };

        reader.readAsText(file);
    });

    // --- Submit CSV for prediction (unchanged) ---
    submitBtn.addEventListener("click", async () => {
        console.log("[DEBUG] Submit button clicked.");

        if (!fileInput.files[0]) {
            alert("Please upload a CSV first!");
            console.warn("[DEBUG] Submit blocked: no CSV file uploaded.");
            return;
        }

        if (!stackSelect.value) {
            alert("Please select a model stack!");
            console.warn("[DEBUG] Submit blocked: no model stack selected.");
            return;
        }
        
        // Ensure results section is visible to show metrics
        resultsDiv.classList.remove("hidden"); 
        // Display metrics before starting the fetch
        displayMetrics(stackSelect.value); 

        // Build mapping: CSV column â†’ base feature
        const mapping = {};
        let allMapped = true;
        
        // ... (rest of mapping logic is unchanged)

        columnMappingDiv.querySelectorAll("select").forEach(select => {
            if (!select.value) {
                allMapped = false;
                console.warn("[DEBUG] Unmapped feature:", select.dataset.feature);
            } else {
                mapping[select.value] = select.dataset.feature;
            }
        });

        if (!allMapped) {
            alert("Please map all required features!");
            return;
        }

        console.log("[DEBUG] Final mapping:", mapping);

        const formData = new FormData();
        formData.append("stack", stackSelect.value);
        formData.append("mapping", JSON.stringify(mapping));
        formData.append("csv", fileInput.files[0]);

        try {
            console.log("[DEBUG] Sending request to backend with stack:", stackSelect.value);

            const response = await fetch("http://127.0.0.1:5000/predict", {
                method: "POST",
                body: formData
            });

            console.log("[DEBUG] Response status:", response.status);

            const contentType = response.headers.get("content-type");
            console.log("[DEBUG] Response Content-Type:", contentType);

            if (contentType && contentType.includes("application/json")) {
                const result = await response.json();
                console.error("[DEBUG] Backend returned JSON (likely error):", result);

                resultsDiv.classList.remove("hidden");
                predOutput.textContent = JSON.stringify(result, null, 2);
                alert("Backend error: " + JSON.stringify(result));
                return;
            }

            // âœ… get the blob if no error JSON
            const blob = await response.blob();
            console.log("[DEBUG] Blob received, size:", blob.size);

            if (blob.size === 0) {
                alert("Received empty file. Something went wrong on the server.");
                console.error("[DEBUG] Blob is empty.");
                return;
            }

            const url = window.URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `all_predictions_${stackSelect.value}.zip`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            window.URL.revokeObjectURL(url);

            console.log("[DEBUG] File download triggered.");

        } catch (err) {
            console.error("[DEBUG] Fetch error:", err);
            // This alert remains for network/CORS issues
            alert("Something went wrong while predicting."); 
        }
    });
});
</script>
</body>
</html>